---
title: 切片集合管理原理
---

# 切片集合管理原理

在 DICOM 序列中，每张切片都是一个独立的实体，但它们之间又存在严格的顺序关系。`DicomSliceManager` 扮演了集合管理者的角色，维护着内部切片列表，负责添加、排序以及释放切片资源。理解其工作原理有助于编写更健壮的加载和卸载逻辑。

## 添加切片

### `AddSlice(DicomSlice slice)`

此方法用于将一个新的切片加入列表：

1. **空值检查**：如果传入的 `slice` 为 `null`，方法直接返回，不做任何处理。这样可以在加载流程中避免因为异常读取导致的空引用报错。
2. **重复检查**：在内部列表中搜索是否已存在相同的切片(通常通过比对实例号或文件路径)，若已存在则忽略该切片。避免重复添加可以防止排序时索引错乱，并节省内存。
3. **加入列表**：若切片有效且不重复，就将它追加到列表末尾。

> **注意：** `DicomSliceManager` 并不会在 `AddSlice` 时调整 `SequenceIndex`；该索引直到排序后才会更新。如果需要在加载过程中显示进度，请根据当前切片数量而非 `SequenceIndex` 计算。

## 排序切片

DICOM 文件可能来自不同的设备或存储方式，切片顺序不一定按文件名或实例号排列。`DicomSliceManager.SortSlices()` 使用 `DicomSlice.CompareByZPosition` 将切片按解剖顺序重新排列：

1. **排序键**：算法首先比较 `SliceLocation`(切片位置)，若存在相同位置，则比较 `ImagePositionPatient.z`，最后比较 `InstanceNumber`。这种组合键能够在多种情况下得出正确顺序，例如当某些 DICOM 缺少 `SliceLocation` 或不同生产商使用不同的排序标签时。
2. **更新索引**：排序完成后，会对列表重新编号，分别写入每个切片的 `SequenceIndex` 字段。该索引表示该切片在整个序列中的位置，从 0 开始递增。

> **调用时机：** 请在所有切片都加载完成之后再调用 `SortSlices()`，否则后续的 `AddSlice` 操作将打乱已有顺序。另外，在排序之后不要再向 `DicomSliceManager` 添加切片，除非重新排序。

## 释放资源

切片数据(尤其是纹理和像素数组)占用大量内存。`DicomSliceManager.ReleaseSlices()` 的职责是遍历所有切片，调用每个切片的 `Dispose()`，然后清空内部列表。具体步骤如下：

1. **遍历切片**：按顺序调用每个切片的 `ReleaseTexture()` 释放 GPU 纹理，然后清空像素数据，并标记为未解码。
2. **清空列表**：在释放完所有切片后，将 `Slices` 列表置空并重置计数。这样能确保后续加载新的序列不会受到旧数据影响。

建议在场景切换或重新加载数据前调用 `ReleaseSlices()`，以避免显存泄漏和堆内存占用。

## 设计理念

`DicomSliceManager` 将切片集合维护从 `DicomSeries` 中抽离，减少了序列类的职责，使其更专注于暴露 API 和管理元数据。切片管理器保证了以下几个原则：

- **可靠性**：避免重复添加和处理空引用，提高了加载流程的容错能力。
- **灵活性**：提供独立的排序功能，允许根据具体需求在任何时刻对切片重新排序。
- **资源控制**：集中释放切片资源，提高内存管理的可控性。在大型数据集或频繁切换序列的场景中尤为重要。

## 进一步阅读

请参考如何文档 [管理切片](/guide/core/how_to/02_manage_slices.md)，其中提供了完整示例，演示如何创建切片、添加到序列、排序并释放资源。

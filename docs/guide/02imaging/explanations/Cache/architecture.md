# 缓存架构与数据结构 

本节介绍 `DicomTextureCache` 的内部设计。理解这些结构有助于后续修改缓存策略或定位问题。

## 多平面缓存

`DicomTextureCache` 维护三套独立的缓存，每套通过 `Dictionary<string, Texture2D>` 存储纹理。键由平面类型、切片索引和窗宽窗位组合而成，例如 `Axial_12_40-400`。每个平面还有一条对应的 LRU 链表，用于记录最近使用顺序。

缓存还追踪以下信息：

* **纹理大小和总占用**：`_textureSizes` 记录每个键对应纹理的字节数，总占用按平面累加。
* **缓存上限与内存限制**：每个平面有独立的最大数量和内存上限，超过阈值时触发淘汰。
* **窗口宽窗位映射**：为了快速失效旧缓存，`_windowLevelToTextureKeys` 维护窗宽窗位到缓存键的索引。
* **引用计数与状态集合**：缓存通过 `_activeTextures`、`_visibleTextures`、`_permanentTextures` 和 `_textureRefCounts` 区分正在使用、屏幕可见、永久锁定的纹理。

## 选择锁与最后有效纹理

当用户快速移动切片时，为避免频繁销毁再创建纹理，Cache 实现了一个“选择锁”机制：在短时间内禁止淘汰当前显示的纹理，并将最后有效的纹理保留在 `_lastValidTextures` 中。锁定会自动在设定时间后释放。

## 缓存键与窗宽窗位

窗宽窗位 (Window Level/Width) 决定了像素灰度映射。在缓存中，这两个值经 `Mathf.Round` 处理后拼接为字符串，如 `100-400`。生成缓存键时，平面类型和索引会与该字符串一同构成唯一标识。

调用 `SetCurrentWindowLevelKey(center, width)` 更新当前 WL/WW 时，会影响后续生成的缓存键。同时，旧窗口键关联的纹理可以在适当时机批量清理。

## 线程安全

大多数缓存操作都使用 `_cacheLock` 加锁，确保在多线程或异步协程环境下数据一致。在修改缓存前应先锁定该对象。

若需扩展缓存结构或增加其他平面，请按照现有模式维护对应的字典、LRU 列表和统计字段。